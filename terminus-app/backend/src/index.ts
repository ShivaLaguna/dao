import Koa from "koa";
import Router from "@koa/router";
import cors from "@koa/cors";
import axios, { Axios, AxiosError, AxiosResponse } from "axios";
import Web3 from "web3";
import * as fs from "fs";
import * as path from "path";
import BugoutClient, {
  BugoutResponseError,
  BugoutTypes,
} from "@bugout/bugout-js";
import * as TerminusFacet from "./abi/TerminusFacet.json";
import { BugoutResources } from "@bugout/bugout-js/lib/types";
import { v4 } from "uuid";

const TERMINUS_APPLICATION_PORT =
  process.env.TERMINUS_APPLICATION_PORT || 14601;
if (!process.env.TERMINUS_APPLICATION_ID)
  throw "TERMINUS_APPLICATION_ID not provided";

const TERMINUS_APPLICATION_ID = process.env.TERMINUS_APPLICATION_ID;
const BROOD_AUTH_URL = process.env.BROOD_AUTH_URL || "https://auth.bugout.dev";

const BROOD_AUTH_TOKEN = process.env.BROOD_AUTH_TOKEN;
if (!BROOD_AUTH_TOKEN) throw "BROOD_AUTH_TOKEN is not exported";

const multer = require("@koa/multer");
const app = new Koa();
const data = multer();
const router = new Router();
const corsConfiguration = cors({ allowMethods: "GET" });
const web3 = new Web3(`https://rpc-mainnet.matic.network`);

const TERMINUS_CONTRACT_TYPE = "terminus_contract_type";
const TERMINUS_CLIENT_TYPE = "terminus_client_type";
const WEB3_ADDRESS = "web3_address_type";

const bc = new BugoutClient(BROOD_AUTH_URL);
bc.pingBrood().then((response: BugoutTypes.BugoutPing) =>
  console.log(`ping brood:`, response)
);

const BUGOUT_RESOURCE_TYPE_SUBSCRIPTION = "subscription";

export type BugoutUser = {
  id: string;
  username: string;
  first_name?: string;
  last_name?: string;
  email?: string;
  normalized_email?: string;
  verified?: string;
  autogenerated?: string;
  application_id?: string;
  created_at?: string;
  updated_at?: string;
};

export function userUnpacker(response: any): BugoutUser {
  return {
    id: response.user_id,
    username: response.username,
    first_name: response.first_name,
    last_name: response.last_name,
    email: response.email,
    normalized_email: response.normalized_email,
    application_id: response.application_id,
    verified: response.verified,
    created_at: response.created_at,
    updated_at: response.updated_at,
  } as BugoutUser;
}
interface Address {
  id: string;
  chainId: string;
  address: string;
  token_hash: string; //hash of access token
  customer_id: string; //foreign key to customer.id
}

interface Customer {
  id: string; // primary key we use to refer to customer in DB
  name: string; // name of customer
  notes: string; // human-readable/writeable notes about customer
}

interface Contract {
  id: string; // primary key we use to refer to contract in DB
  blockchain: string; // chain which Terminus contract is deployed
  address: string; // address of the contract on that blockchain
  customer_id: string; // foreign key to Customer.id
  controller: string; // address of Terminus controller
  name: string; // human friendly name for contract
  notes: string; // human friendly notes about contract
}

interface PoolAuthorization {
  id: string; // primary key
  pool_id: string; // foreign key into Pool.id
  address: string; // authorized address for pool
}

interface PoolOwner {
  id: string; // primary key
  pool_id: string; // foreign key into Pool.id
  address: string; // address of token owner
  num_tokens: string; // number of tokens they own
}

interface AddressAnnotation {
  address: string;
  annotator: string; // address of account that created annotation
  name: string; // name for address
  notes: string; // notes for address
}

interface StatusResponse {
  lastRefresh: number;
  nextRefresh: number;
}

const toTimestamp = (strDate: string) => {
  const dt = Date.parse(strDate);
  return dt / 1000;
};

//Error middleware
router.use(async (ctx, next) => {
  try {
    await next();
  } catch (err: any) {
    let message = err.response?.data?.detail || err.message || "Unknown Error";
    let status = err?.response?.status || err?.statusCode || err?.status || 500;
    console.log("***************************");
    console.log("Middleware catched an error:", status);
    console.log(message);
    console.log("***************************");
    ctx.throw(status, message);
  }
});

// const getContract =
//   (ctx: Koa.BaseContext, next: () => Promise<any>) =>
//   async (address: string) => {
//     if (!web3.utils.isAddress(address)) {
//       ctx.status = 422;
//       ctx.body = { error: "Is not address" };
//     } else {
//       const token = ctx.headers.authorization ?? "";
//       const resource = await bc
//         .listResources(token, { contract_address: address })
//         .then((response: BugoutTypes.BugoutResources) => response.resources[0])
//         .then(async (resource) => {
//           const terminus_resource = await bc.getResource(token, resource.id);
//         });

//       ctx.status = 200;
//       ctx.body = terminus_resource;
//     }
//     next();
//   };

async function checkAuth(ctx: Koa.BaseContext, next: () => Promise<any>) {
  if (ctx.headers["authorization"]) {
    const user_token_list = ctx.headers["authorization"].split(" ");
    if (user_token_list.length != 2) {
      ctx.status = 403;
      ctx.body = { error: "Wrong authorization header" };
    } else {
      try {
        let url = `${BROOD_AUTH_URL}/user`;

        const response = await axios.get(url, {
          headers: { authorization: `Bearer ${user_token_list[1]}` },
        });

        const user = userUnpacker(response.data);

        if (!user.verified) {
          console.log(
            `Attempted journal access by unverified Brood account: ${user.id}`
          );
          ctx.status = 403;
          ctx.body = { error: "Wrong authorization header" };
        } else {
          if (user.application_id != TERMINUS_APPLICATION_ID) {
            ctx.status = 403;
            ctx.body = { error: "User does not belong to this application" };
          } else {
            await next();
          }
        }
      } catch (Error: any) {
        console.log(Error);
        ctx.status = 404;
        ctx.body = { error: `Credential not found` };
      }
    }
  } else {
    ctx.status = 404;
    ctx.body = { error: "Authorization header not found" };
  }
}

// router.use(["/update"], checkAuth);

// async function syncBucket(app: any) {
//   // Request data update
//   let url = `https://s3.amazonaws.com/static.simiotics.com/LEADERBOARD_DATA/IMDEX_FILE.json`;

//   // Post will return access link response structure
//   // {"url": presign_url}
//   let response = await axios.get(url, {
//     headers: { "Content-Type": "application/json" },
//   });

//   app.context.index_data = await response.data;

//   // Request data update
//   url = `https://s3.amazonaws.com/static.simiotics.com/LEADERBOARD_DATA/FULL_LIST.json`;

//   // Post will return access link response structure
//   // {"url": presign_url}
//   response = await axios.get(url, {
//     headers: { "Content-Type": "application/json" },
//   });

//   app.context.full_data = await response.data;
//   app.context.last_modified = response.headers["last-modified"];
//   console.log("synchronized");
// }

// syncBucket(app);

router.get("/web3auth/:chainId/:address", async (ctx, next) => {
  const web3 = new Web3();
  const { address, chainId } = ctx.params;
  const quest = web3.utils.keccak256(
    address + chainId + String(Math.floor(Date.now() / 60000))
  );
  ctx.body = { quest: quest };
});

router.post(
  "/web3auth/:chainId/:address",
  data.single("signature"),
  async (ctx, next) => {
    const web3 = new Web3();
    const { address, chainId } = ctx.params;

    const request = ctx.request as any;
    const { signature } = request.body;
    const quest = web3.utils.keccak256(
      address + chainId + String(Math.floor(Date.now() / 60000))
    );

    const verify = await web3.eth.accounts.recover(quest, signature);
    if (address == verify) {
      // await next()

      const listResources = await bc.listResources(BROOD_AUTH_TOKEN, {
        blockchain: chainId,
        address: address,
        type: WEB3_ADDRESS,
      });
      if (listResources.resources.length === 0) {
        const newToken = v4();
        const resourceData = {
          id: v4(),
          address: address,
          chainId: chainId,
          token_hash: web3.utils.keccak256(newToken),
        };
        await bc.createResource(
          BROOD_AUTH_TOKEN,
          TERMINUS_APPLICATION_ID,
          resourceData
        );
        ctx.body = newToken;
      } else {
        const resource = listResources.resources[0];
        const newToken = v4();
        const resourceData = {
          ...resource.resource_data,
          token_hash: web3.utils.keccak256(newToken),
        };
        bc.updateResource(BROOD_AUTH_TOKEN, resource.id, resourceData, []);
        ctx.body = newToken;
      }
    }
  }
);

router.get("/terminus/:chainId/:contractAddress", async (ctx, next) => {
  const { contractAddress, chainId } = ctx.params;

  // const accessLevel = await next(chainId, contractAddress, ctx, next)
  // await next();
  // const ResourceState =
  //
  console.log("got ", contractAddress, chainId);
  // ctx.body = "lol";
  // ctx.satus = 200;
  let resources: Array<any> = [];
  if (!web3.utils.isAddress(contractAddress)) {
    ctx.throw(422, "Is not address");
  } else {
    console.log("getting contracts list");
    // try {
    const contractsList = await bc.listResources(BROOD_AUTH_TOKEN, {
      blockchain: chainId,
      address: contractAddress,
      type: TERMINUS_CONTRACT_TYPE,
    });
    resources = contractsList?.resources;
    // } catch (err: any) {
    //   console.log(err.message);
    // }

    let terminus_resource;

    if (resources.length === 0) {
      console.log("got zero resources -> create one...");
      let customerId: string | null = "";
      try {
        const customer = await bc.listResources(BROOD_AUTH_TOKEN, {
          type: TERMINUS_CLIENT_TYPE,
          address: contractAddress,
          blockchain: chainId,
        });
        customerId =
          customer.resources.length > 0 ? customer.resources[0].id : null;
      } catch (error: any) {
        console.error(error?.message);
      }
      console.log("Searching for customer id:", customerId);

      const newResourceData = {
        blockchain: chainId,
        address: contractAddress,
        customer_id: customerId,
        controller: "",
        name: "",
        notes: "",
        type: TERMINUS_CONTRACT_TYPE,
      };
      console.log("Attempt to create resource", TERMINUS_APPLICATION_ID);
      try {
        console.log("with token", BROOD_AUTH_TOKEN);
        terminus_resource = await bc.createResource(
          BROOD_AUTH_TOKEN,
          TERMINUS_APPLICATION_ID,
          newResourceData
        );
      } catch (error: any) {
        ctx.throw(error.response.status, error.response.data.detail);
      }

      console.log("checking subscriptions");
      const params = {
        type: BUGOUT_RESOURCE_TYPE_SUBSCRIPTION,
        address: contractAddress,
        subscription_type_id: "polygon_blockchain",
      };
      const listResources = await bc.listResources(BROOD_AUTH_TOKEN, params);
      if (listResources.resources.length === 0) {
        console.log("no subscriptions found -> create one");
        const newResourceData = {
          type: BUGOUT_RESOURCE_TYPE_SUBSCRIPTION,
          address: contractAddress,
          subscription_type_id: "polygon_blockchain",
          abi: JSON.stringify(TerminusFacet),
        };
        await bc.createResource(
          BROOD_AUTH_TOKEN,
          TERMINUS_APPLICATION_ID,
          newResourceData
        );
        console.log("created subscription");
      } else {
        console.log("found subscription");
      }
    } else {
      console.log("found resource!", resources[0]);
      terminus_resource = await bc.getResource(
        BROOD_AUTH_TOKEN,
        resources[0].id
      );
    }
    ctx.status = 200;
    ctx.body = terminus_resource;
    await next();
  }

  /*

  GET /terminus/${DiamondAddress} -> (TerminusContract):

  terminus_contract_resource_id: BugoutResource = bc.list_resources(
                  params = { "contract_address": DiamondAddress }
              )[0]
  terminus_resource = bc.get_resource( resource_id = terminus_contract_resource_id)

  1. Update resource from web3 provider
  2. Return resource

  Case if terminus_contract not found:
  Check web3 -> if contract exists and payment service conditions are met - create resource and set up crawler

  */
});

router.get(
  "/terminus/:chainId/:contractAddress/pools/:poolId",
  async (ctx, next) => {
    console.log("get pool id");
  }
);

// router.get("/terminus/:DiamondAddress/pools/:poolId", async (ctx) => {
//   /*

//   GET /terminus/${DiamondAddress}/pools/${poolId} -> (TerminusPool):
//   terminus_pool: BugoutResource = bc.get_resource(
//                   resource_id=terminus_contract[poolId],
//               )
//   1. Update resource from web3 provider
//   2. Return resource

//   Case if resource not found:
//   If payment service conditions are met - create resource and set up crawler.
//     For each address found in crawler:
//       add TerminusIdentity.

//   */
// });

// router.get("/terminus/:DiamondAddress/pools/:poolId/:address", async (ctx) => {
//   /*

//   GET /terminus/${DiamondAddress}/pools/${poolId}/${address} -> (TerminusIdentity)
//   terminus_pool_resource: BugoutResource = bc.get_resource(
//                   resource_id=terminus_pool.identities[],
//               )
//   if address in terminus_pool_resource.identities
//       terminus_identity_resource: BugoutResource = bc.get_resource(
//                   resource_id=address,
//               )
//       terminus_identity_record_resource: BugoutResource = bc.get_pool_resource(
//                   resource_id=web3.sha(DiamondAddress + poolId + address),
//               )

//   */
// });

// router.get("/status", async (ctx) => {
//   const nowEpoch = toTimestamp(ctx.last_modified);
//   const response: StatusResponse = {
//     lastRefresh: nowEpoch,
//     nextRefresh: nowEpoch + 10800,
//   };
//   ctx.body = response;
// });

//
router.use(async (ctx, next) => {
  //Check user address token
  if (ctx.headers["authorization"]) {
    const user_token_list = ctx.headers["authorization"].split(" ");
    if (user_token_list.length == 2) {
      try {
        const res = await bc.findFirstResource(BROOD_AUTH_TOKEN, {
          type: WEB3_ADDRESS,
          token_hash: web3.utils.keccak256(user_token_list[1]),
        });
        console.log("address found:", res.resource_data.address);
      } catch (err) {
        const _err = err as BugoutResponseError;
        console.log("address resource not found", _err.message);
        ctx.throw(404, { message: "Token is invalid" });
      }
    }
  }
});

// router.use(async (ctx, next) => {
//   console.log("Payment middleware");
//   await next();
// });

app.use(corsConfiguration).use(router.routes());

app.listen(TERMINUS_APPLICATION_PORT, () => {
  console.log(
    `Terminus web app server listening on port ${TERMINUS_APPLICATION_PORT}`
  );
});
